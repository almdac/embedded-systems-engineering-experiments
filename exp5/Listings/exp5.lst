C51 COMPILER V9.59.0.0   EXP5                                                              04/21/2019 14:17:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EXP5
OBJECT MODULE PLACED IN .\Objects\exp5.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE exp5.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\exp5
                    -.lst) TABS(2) OBJECT(.\Objects\exp5.obj)

line level    source

   1          #include <REG51F.H>
   2          
   3          #define BASE 204  
   4          #define RING_SIZE 16 // Length of circular buffers
   5          
   6          unsigned char rx_ring[RING_SIZE]; // Reception circular buffer
   7          unsigned char tx_ring[RING_SIZE]; // Transmission circular buffer
   8          unsigned char rx_head = 0, rx_tail = 0, tx_head = 0, tx_tail = 0, tx_busy = 0;
   9          
  10          void serial_interrupt(void) interrupt 4 using 2 { // Interrupt while there's something to be transmitted o
             -r received
  11   1        if (TI == 1) {
  12   2          T1 = 0;
  13   2          if (tx_head != tx_tail) { // Is there something to be transmitted?
  14   3              SBUF = tx_ring[tx_head];
  15   3              tx_head = (tx_head + 1) % RING_SIZE;
  16   3          } else tx_busy = 0; // Not busy anymore (transmission done)
  17   2        }
  18   1        
  19   1        if (RI == 1) {
  20   2          RI = 0;
  21   2          if ((rx_tail + 1) % RING_SIZE != rx_head) { // Is there space in rx_ring to receive a new char?
  22   3            rx_ring[rx_tail] = SBUF;
  23   3            rx_tail = (rx_tail + 1) % RING_SIZE;
  24   3          }
  25   2        }
  26   1      }
  27          
  28          void start_timer() { // Set timer 1 to be used in 8-bit autoreload mode as baudrate for the serial interfa
             -ce
  29   1        TR1 = 0; // Stop timer
  30   1        TMOD = (TMOD & 0xF0) | 0x20; // 8-bit autoreload. TLx is automatically reloaded from THx
  31   1        PCON = (PCON & 0x0F) | 0x80; // SMOD = 1
  32   1        TH1 = BASE; 
  33   1        TL1 = BASE;
  34   1        TR1 = 1; // Continue timer
  35   1      }
  36          
  37          void start_serial() { // Set serial interface to be used in mode 1
  38   1        ES = 0; // Stop serial interface
  39   1        SCON = (SCON & 0x0F) | 0x50; // Mode 1, Reception enabled
  40   1        ES = 1; // Enable serial interface
  41   1      }
  42          
  43          void sendChar(char c) { // Append and/or trigger a transmission of a byte through the circular buffer tx_r
             -ing
  44   1        if ((tx_tail + 1) % RING_SIZE != tx_head) { // Is there space in tx_ring to append a char? 
  45   2          tx_ring[tx_tail] = c;
  46   2          tx_tail = (tx_tail + 1) % RING_SIZE;
  47   2        }
  48   1        
  49   1        if (!tx_busy) { // Trigger a transmission if a transmission isn't happening
  50   2          tx_busy = 1;
  51   2          TI = 1;
C51 COMPILER V9.59.0.0   EXP5                                                              04/21/2019 14:17:16 PAGE 2   

  52   2        }
  53   1      }
  54          
  55          void sendString(char *s) { // Transmit a string
  56   1        unsigned char i;
  57   1        for (i = 0; s[i] != '\0'; i++) sendChar(s[i]);
  58   1      }
  59          
  60          char RxBufferVazio() { // Check whether the circular buffer rx_ring is empty
  61   1        if (rx_head == rx_tail) return 1;
  62   1        else return 0;
  63   1      }
  64          
  65          char receiveChar() { // Return a byte from the circular buffer rx_ring
  66   1        char c;
  67   1        
  68   1        if (!RxBufferVazio()) { // Is there something to be received?
  69   2          c = rx_ring[rx_head];
  70   2          rx_head = (rx_head + 1) % RING_SIZE;
  71   2        } return '\0'; // Else, end of string
  72   1        
  73   1        return c;
  74   1      }
  75          
  76          void receiveString(char *s) { // Receive a string from buffer and copy to s
  77   1        unsigned char i = 0;
  78   1        char c;
  79   1        
  80   1        do {
  81   2          c = receiveChar();
  82   2          s[i] = c;
  83   2          i++;
  84   2        } while (c != '\0');
  85   1      }
  86          
  87          void main() {
  88   1        start_timer();
  89   1        start_serial();
  90   1        EA = 1; // Enable all interrupt
  91   1        
  92   1        while(1);
  93   1      }
*** WARNING C294 IN LINE 73 OF exp5.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    244    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
